% Dictator game
% modeling


function result = nmodel_9(bootData)

nLoops = 1; %number of random starts
bestRsq = 0;

for i = 1:nLoops
%     disp(i)    
% random starts for parameters%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rho = rand*2-1;
sigma =  rand*2-1;
gamma = rand(1);
lambda = rand(1);
inx0 = [rho sigma gamma lambda];


try

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
lb = [-1,-1,0,0];
ub = [1,1,1,inf];
[b, fval] = fmincon(@DG_m2,inx0,[],[],[],[],lb ,ub ,[], optimset('Algorithm', 'interior-point'),bootData);
[loglike, prob_chosen] = DG_m2(b, bootData);

params = b;
modelLL = -loglike;      %loglikelihood here should be negative for model
nullLL = log(0.5)*length(bootData'); %null model
pseudoR2 = 1 -  nullLL/ modelLL; %0 to 1 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Mon_s = bootData(:,6) .* bootData(:,4);	% possible payoff for self
Mon_o = (bootData(:,3) - bootData(:,6)) .* bootData(:,5);	% possible payoff for other
bic = 2*loglike + 4*log(length(bootData')) +...
    log(length(Mon_s>=Mon_o))+log(length(Mon_s<Mon_o));
result.thisloglike(i) = loglike;

catch           % returns the last error message generated by MATLAB
lasterr
end;

% if pseudoR2 > bestRsq
    bestRsq = pseudoR2;
    result.params = b;
    result.pseudoR2 = pseudoR2;
    result.loglike = loglike;
    result.bic = bic;
% else
% end

end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [loglike, prob_chosen] = DG_m2(q0,bootData)

rho = q0(1);
sigma = q0(2);
gamma = q0(3);
lambda = q0(4);

for t=1:size(bootData,1)

Ts = 0:bootData(t,3); 	% possibel choices for self
Ms = Ts * bootData(t,4);	% possible payoff for self
Mo = (bootData(t,3) - Ts) * bootData(t,5);	% possible payoff for other
MM= max(bootData(t,4),bootData(t,5)) * bootData(t,3);
rate=(Ms + Mo)/ MM;
% U =Ms - ((Ms>=Mo)*rho) .* (Ms-Mo) - ((Ms<Mo)*sigma) .* (Mo-Ms)+ (Ms + Mo) .* gamma;
% U =(Ms - ((Ms>=Mo)*rho) .* (Ms-Mo) - ((Ms<Mo)*sigma) .* (Mo-Ms)) .*(((Ms + Mo)/ MM).^ (1-gamma));
U =(Ms - ((Ms>=Mo)*rho) .* (Ms-Mo) - ((Ms<Mo)*sigma) .* (Mo-Ms)) .* ( 1- gamma *(1-rate));

% U = ((Ms>=Mo)*rho + (Ms<Mo)*sigma) .* Mo +  (1 - (Ms>=Mo)*rho - (Ms<Mo)*sigma) .* Ms + (Ms + Mo) .* gamma;
prob = exp(lambda * U) / nansum(exp(lambda * U));
prob_chosen(t,1) = prob(bootData(t,6)+1);

end

loglike = -nansum(log(prob_chosen));

end

